angular.module('F1FeederApp.controllers').
  
  controller('alarmManagementController', function($scope, $routeParams, $location, $rootScope, $localStorage, ergastAPIservice) {
    $scope.id = $routeParams.id;
    $scope.races = [];
    $scope.driver = null;
	$rootScope.loggedIn = false;
	$scope.userName = null;
	$scope.password = null;
	var allDeviceList = [];
	$scope.deviceAvilable = [];

	$scope.isEditMode = false;


	var selectedRule = null;


	$('.collapse').on('shown.bs.collapse', function () {
	    $(this).parent().find(".glyphicon-plus").removeClass("glyphicon-plus").addClass("glyphicon-minus");
	}).on('hidden.bs.collapse', function () {
	    $(this).parent().find(".glyphicon-minus").removeClass("glyphicon-minus").addClass("glyphicon-plus");
	});


	$scope.deleteAlarmRule = function () {


	    if (confirm("Are you sure to remove Rule ? Removing rule will also delete all alarms generated by that rule") == false) {
	        return;
	    }
	    if ($scope.isEditMode) {
	        $scope.editCancel();

	    }

	    ergastAPIservice.deleteAlarmRule(selectedRule.ruleName, function (err) {
	        if (!err) {
	            alert("Successfully removed selected Rule.")

	            for (var i = 0; i < $scope.alarmrules.length; i++) {
	                if ($scope.alarmrules[i].ruleName == selectedRule.ruleName) {
	                    $scope.alarmrules.splice(i, 1);
	                    break;
	                }
	            }

	        }

	    });
	}

	$scope.updateRuleButtonClick = function () {

	}
	$scope.ruleDeviceTypeChanged = function () {
	    showDevicesForType($scope.newRuleDevType);
	    showRuleParams($scope.newRuleDevType, function () { });
	}
	$scope.editCancel = function () {
	    $scope.isEditMode = false;

	    $scope.newRuleName = null;
	    $scope.newRuleActiveTime = null;
	    $scope.newRuleMsg = null;

	    for (var j = 0; j < $scope.deviceAvilable.length; j++) {
	        $scope.deviceAvilable[j].isSelected = false;
	    }

	    for (var j = 0; j < $scope.seletedClassParamInfo.length; j++) {
	        $scope.seletedClassParamInfo[j].minLimit = null;
	        $scope.seletedClassParamInfo[j].maxLimit = null
	    }

	}
	$scope.editAlarmRule = function () {
	    $scope.isEditMode = true;
        // load selected rule to UI.
	    $scope.newRuleName = selectedRule.ruleName;
	    $scope.clearingMode = selectedRule.clearingMode;
	    $scope.newRuleActiveTime = selectedRule.timeInterval;
	    
	    $scope.newRuleMsg = selectedRule.message;
	    $scope.ruleCombinedCondition = selectedRule.combinedCondition;
        
	    if(selectedRule.type == "device"){
	        $scope.newRuleDevType = selectedRule.info.devType;
	        showDevicesForType($scope.newRuleDevType);
	        var devIds = selectedRule.info.deviceIds;
	        for (var j = 0; j < devIds.length; j++) {
	            var res = $scope.deviceAvilable.find(function (obj) {
	                return obj.deviceId == devIds[j].deviceId;
	            });
	            if (res != null) {
	                res.isSelected = true;
	            }
	        }

	        showRuleParams($scope.newRuleDevType, function () {

	           
	           

	            var paramDefs = selectedRule.info.paramDefs;
	            for (paramName in paramDefs) {
	                var res = $scope.seletedClassParamInfo.find(function (obj) {
	                    return obj.paramName == paramName;
	                });
	                if (res != null) {
	                    res.minLimit  = paramDefs[paramName].minLimit;
	                    res.maxLimit = paramDefs[paramName].maxLimit;

	                }
	            }
	        });
	    }
	  
	}

	$scope.selectRule = function (row, rule) {

        
	    if ($scope.isEditMode) {
	        if (confirm("Are you sure to cancel current edit ?"))
	        {
	            $scope.editCancel();
	        }
	        else
	        {
	            return;
	        }
	        
	    }
	    $scope.selectedRow = row;
	    selectedRule = rule;

	  

	}

	var updateRuleInUI = function (rule) {

	    for (var j = 0; j < $scope.alarmrules.length; j++) {

	        if ($scope.alarmrules[j].ruleName == rule.ruleName) {
	            $scope.alarmrules[j] = rule;
	            break;
	        }
	    }
	   
	}
	$scope.updateRuleButtonClick = function () {
	    var info = getAlarmRuleObjectFromUI();
	    if (info == null) {
	        alert("Unable to add new rule. Unknown error!.")
	        return;
	    }
	    ergastAPIservice.updateAlarmRule(info, function (err) {
	        if (!err) {
	            alert("Rule updated successfully")
	            updateRuleInUI(info);

	            $scope.editCancel();
	        }
	        else {
	            alert("Unable to update rule, check your connection.");
	        }
	    });
	}

	var validateUIData = function(){
	
	    
	    var rule = getAlarmRuleObjectFromUI();
	    if (rule.ruleName == null || rule.ruleName.trim() == "") {
	        return false;
	    }

	    if (rule.info.deviceIds == null || rule.info.deviceIds.length <= 0)
	        return false;


	    if (Object.keys(rule.info.paramDefs).length <= 0) {
	        return false;
	    }
	
	    return true;
	}

	$scope.addRuleButtonClick = function () {
	   
	    if ($scope.deviceAvilable == null)
	        return;
            

	    if (!validateUIData()) {
	        alert("Please fill manadatory parameters for the rule.");
	        return;
	    }

	    var info = getAlarmRuleObjectFromUI();
	    if (info == null)
	    {
	        alert("Unable to add new rule. Unknown error!.")
	        return;
	    }
	    ergastAPIservice.addAlarmRule(info, function (err) {
	        if (!err) {
	            addRuleToUI(info);
	            alert("Rule added successfully")
	        }
	        else {
	            alert("Unable to add rule");
	        }
	    });
	}

	var getAlarmRuleObjectFromUI = function () {

	    var selectedDeviceIds = [];
	    for (var j = 0; j < $scope.deviceAvilable.length; j++) {
	        if ($scope.deviceAvilable[j].isSelected) {
	            selectedDeviceIds.push({
	                deviceId: $scope.deviceAvilable[j].deviceId,
	                logicalDeviceId: $scope.deviceAvilable[j].tag.logicalDeviceId
	            });
	        }
	    }

	    var paramDefs = {};
	    for (var j = 0; j < $scope.seletedClassParamInfo.length; j++) {
	        if ($scope.seletedClassParamInfo[j].minLimit != null || $scope.seletedClassParamInfo[j].maxLimit != null) {

	            paramDefs[$scope.seletedClassParamInfo[j].paramName] = {};
	            paramDefs[$scope.seletedClassParamInfo[j].paramName].displayName = $scope.seletedClassParamInfo[j].displayName;
	            paramDefs[$scope.seletedClassParamInfo[j].paramName].minLimit = $scope.seletedClassParamInfo[j].minLimit;
	            paramDefs[$scope.seletedClassParamInfo[j].paramName].maxLimit = $scope.seletedClassParamInfo[j].maxLimit;
	        }
	    }


	    var info = {};
	    info.ruleName = $scope.newRuleName;
	    info.clearingMode = $scope.clearingMode;
	    if (info.clearingMode == "Time") {
	        info.timeInterval = $scope.newRuleActiveTime;
	    }
	    info.message = $scope.newRuleMsg;
	    info.combinedCondition = $scope.ruleCombinedCondition;
	    info.type = "device";
	    info.info = {};
	    info.info.deviceIds = selectedDeviceIds;
	    info.info.paramDefs = paramDefs;
	    info.info.devType = $scope.newRuleDevType;
	    //info.info.paramDefinitions

	    return info;
	}
    
	var fetchAllDevices = function (completionCallBack) {

	    ergastAPIservice.getDeviceCount("", function (count) {
	        var i = 0;
	        var fetchDevice = function () {

	            ergastAPIservice.getDeviceAt(null, i, function (deviceInfo) {
	                if (deviceInfo != null) {

	                    allDeviceList.push(
                        {
                            deviceId: deviceInfo.deviceId,
                            logicalDeviceId: deviceInfo.logicalDeviceId,
                            devFamily: deviceInfo.devFamily,
                            subType: deviceInfo.subType,
                            tag: deviceInfo,
                        });
	                }

	                i++;
	                if (i < count) {
	                    fetchDevice();
	                }
	                else {
	                    completionCallBack();
	                }
	            });

	        }

	        if (i < count) fetchDevice();

	    });
	}

	var showDevicesForType = function (subType) {

	    $scope.deviceAvilable = [];
	    for (var i=0;i<allDeviceList.length;i++){
	        var device  = allDeviceList[i];
	        if (device.subType == subType) {
	            $scope.deviceAvilable.push({ deviceId: device.deviceId, tag: device.tag });
	        }
	    }
	}

	var showRuleParams = function (selectedSubType,callBackCompletion) {
	    $scope.seletedClassParamInfo = [];
	    ergastAPIservice.getDeviceSpec(selectedSubType, function (err, res) {
	        if (!err && res.paramDefinitions!= null) {
	            $scope.seletedClassParamInfo = [];// res.paramDefinitions;

	            for (var i = 0; i < res.paramDefinitions.length; i++) {
	                if (res.paramDefinitions[i].isDisplayEnabled) {
	                    res.paramDefinitions[i].minLimit = null;
	                    res.paramDefinitions[i].maxLimit = null;
	                    $scope.seletedClassParamInfo.push(res.paramDefinitions[i]);
	                }
	            }
	            callBackCompletion();
	        }
	    })
	}

	var addRuleToUI = function (rule) {
	    rule.id = $scope.alarmrules.length + 1;
	    $scope.alarmrules.push(rule);

	}
	var fetchCurrentRules = function (completionCallBack) {
	    $scope.alarmrules = [];
	    ergastAPIservice.getAlarmRuleCount(null, function (err, count) {

	        if (!err && count > 0) {

	            var i = 0;

	            var fetchRule = function () {

	                ergastAPIservice.getAlarmRuleAt(null, i, function (err1, ruleInfo) {
	                    addRuleToUI(ruleInfo);
	                    //$scope.alarmrules.push(ruleInfo);
	                    i++;
	                    if (i < count)
	                        fetchRule();
	                    else {
	                        completionCallBack();
	                    }
	                })


	            }

	            fetchRule();


	        }
	        else
	            completionCallBack();
	    })
	}

	var initPage = function () {

	    fetchAllDevices(function () {
	        $scope.newRuleDevType = "AFMEthernet";
	        showDevicesForType($scope.newRuleDevType);
	        showRuleParams($scope.newRuleDevType, function () { });
	        
	    });
	    
	    fetchCurrentRules(function () { });
	}

	initPage();

  });